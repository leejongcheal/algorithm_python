**** 주요 핵심 : 방문한곳에 대해서 어떠한 처리가 필요함
    1) visit 리스트를 두어서 검사
    2) Map 자체에 값을 주어서 visit 리스트 대체
    3) visit 대신 대용품이 있는 경우 visit 리스트 대체
------> visit은 꼭 들어가야함을 상기하고 생략 가능한지 생각을 해야함,
        생략 가능한지 모르겠다면 visit 리스트를 사용하자.

그래프를 표현하는 2가지 방법
1. 인접행렬(Adjacency Matrix) : 2차원 배열로 그래프의 연결관계를 표현 하는 방식
    장점: 정보를 얻는 속도가 빠름
    단점: 메모리 측면에서 낭비
2. 인접리스트(Adjacency List) : 리스트 or 사전으로 그래프의 연결관계를 표현 하는 방식
    장점: 메모리 측면에서 효율
    단점: 정보를 얻는속도가 느림

시간복잡도
- 인접리스트의 경우 O(V + E)
- 인접행렬의 경우 O(V^2)

*** 먼저 스택이나 큐에 집어 넣은 상태에서 꺼낸 노드에 대해서 작업
*** DFS는 재귀함수를 써서 텀퓨터 시스템의 동작 특성상 실제 프로그램의 수행 시간은 느려질수 있다. 또한 삼성은 sys 모듈을 제한하기에 쓰기도 쉽지않고,
    이를 위해서 재귀함수가 아닌 스택 라이브러리를 이용해 시간 복잡도를 완화하는 테크닉도 있지만 굳이 필요없다.
*** 이러한 이유로 일반적으로 DFS보단 BFS가 코딩테스트에서 조금 더 빠르게 동작한다는 정도를 기억하자.
DFS: 깊이 우선 탐색, 그래프에서 깊은 부분을 우선적을 탐색하는 알고리즘
    스택 개념


 과정
 1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
 2. 스택에서 꺼낸 최상단 노드에 방문하지 않는 인접노드가 있으면 그 인접 노드를 스택에 넣고 방문처리를 한다.
 방문하지않은 인접노드가 없으면 스택에서 [최상단 노드]를 꺼낸다.
 3. 2번의 과정을 더이상 수행할수 없을 때까지 반복한다.


 예제
 1) 재귀함수 사용
 def dfs(graph, v, visited):
    # 현재 노드를 방문 처리
    visited[v] = 1
    print(v, end= '')
    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)

1-1) 현실적인 dfs
def dfs(Map, index):
    global L, res
    # res에 값을 채우면 종료해야함(여러개중 하나만 필요한 경우)
    if res != []:
        return
    # res 구한경우
    if index == len(L):
        res = Map
        return
    x, y = L[index]
    for n in find_posiible_n(Map, x, y):
        Map[x][y] = n
        dfs(Map, index + 1)
        if res != []:
            return
        # 위에서 Map[x][y] = n 을 넣어서 돌아서 나온거는 값을 못구한것
        # 따라서 Map[x][y] = 0 으로 초기화 해주는것
        # 그리고 이러한 순서는 dfs의 핵심이니 copy = deepcopy(Map) 해서 쓸필요가 전혀 없음을 인지
        Map[x][y] = 0


 2) 스택사용 -> 사실 스택 응용 개념인거 같은데
 def bfs(graph, start_node):
      visit = list()
      stack = list()
      stack.append(start_node)
      while queue:
          node = queue.pop()
          # 1번 후순위 인접노드가 dfs중에 다른 노드의 인접노드로 겹치는 경우 방지
          if node not in visit:
              visit.append(node)
              # 인접 노드에서 우선순위가 앞의 노드에 있을경우
              # 사실 순서 상관없으면 reverse없이 사용해도 됨.
              queue.extend(graph[node].reverse())
      return visit


BFS: 너비 우선 탐색, 가까운 노드부터 탐색하는 알고리즘.
    큐 개념, 최소 거리구할때 사용


 과정
 1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
 2. 큐에서 [노드]를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
 3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.


 예제
 from collections import deque
 def bfs(graph, start, visited):
    #큐 구현을 위해 deque 라이브러리 사용
    queue = deque([start])
    #현재 노드를 방문 처리
    visited[start] = 1
    #큐가 빌 떄 까지 반복
    while queue:
        #큐에서 하나의 원소를 뽑아서 출력
        v = deque.popleft()
        print(v, end= " ")
        #해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = 1


3-1 input 예제

3 3
001
010
101

-3

15 14
00000111100000
11111101111110
11011101101110
11011101100000
11011111111111
11011111111100
11000000011111
01111111111111
00000000011111
01111111111000
00011111111000
00000001111000
11111111110011
11100011111111
11100011111111

-8

3-2 input 예제

3 3
110
010
011

-5

5 6
101010
111111
000001
111111
111111

-10







