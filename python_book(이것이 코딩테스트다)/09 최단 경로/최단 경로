접근법
-   최소 거리 -> 최단경로 알고리즘 1) 다익 2) 플로이드
    2가지 경우에 대해서 시간복잡도 계산하고 500이하 N이면 플로이드워셜 만단위 이상 큐 이용 다익스트라
-   a->b->c의 최단 거리의 경우 2가지 접근법
    1. a->b , b->c 에 대해 각각 다익스트라
    2. 플로이드 알고리즘후에 graph[a][b] + graph[b][c] 이용

최단경로는 말그대로 가장 짧은 경로를 찾는 알고리즘이다. 이를 '길 찾기' 문제라고도 부른다.
최단 경로 알고리즘은 이미 상황에 따른 알고리즘이 정립되어 있다. 따라서 유형 암기 필수
알고리즘 종류
1) 다익스트라 최단 경로 : 한 지점에서 다른 특정 지점까지의 최단 경로를 구하는 경우
2) 플로이드 워셜 알고리즘 :모든 지점에서 다른 모든 지점 까지의 최단경로를 모두 구해야 하는 경우
3) 벨만 포드 알고리즘 - 책에서 다루지않음




- 다익스트라 최단 경로 알고리즘 *** 암기 수준으로 공부 필요
이는 그래프에서 여러개의 노드가 있을때,
'특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구하는 알고리즘'
과정
1) 출발 노드 설정
2) 최단 거리 테이블 초기화
3) '방문하지않은 노드'중 '최단 거리가 가장 짧은' 노드 선택
4) 해당 노드를 거쳐 다른 노드로 가는 비용 계산하여 테이블 갱신
5) 3),4) 과정 반복

V: 정점의 갯수, E: 간선의 갯수
단순 다익스트라 O(V^2)
개선된 다익스트라 O(ElogV) --> 중요

- 개선된 다익스트라 - 최단거리가 짧은 노드를 찾는 방식 개선
자료구조: 힙사용 === 우선순위 큐(우선 순위가 높은 데이터 먼저 삭제함)
PriorityQueue 보단 heapq가 더빠르니 'heapq' 위주 사용

1) 출발 노드 설정
2) 최단 거리 테이블 초기화 및 우선순위 q와 start에 대해 q, 테이블 정보 갱신
3) 우선순위 큐를 이용한 '방문하지않은 노드'중 '최단 거리가 가장 짧은' 노드 선택 // 'dist > result[now]로 방문 했는지 확인한다.'
4) 해당 노드를 거쳐 다른 노드로 가는 비용 계산하여 테이블 갱신 1) 갱신할 경우 그값을 우선순위 큐에 push
5) 3),4) 과정 반복

3) 에서 시간효율이 좋음
*** 3) 에서 과정을 자세히 들어다보면
*** if cost < res[index] 인 경우 최단 거리 테이블을 갱신하고 힙에 push한다.
*** 이과정에서 cost만 다른 같은 index값이 중복적으로 힙으로 들어가는 경우가 생김
*** 이를 if res[index] < dist: 일때 무시 하는 방법으로 방문했는지를 검사함
*** 이는 dist가 res[index]보다 크다는 소리는 이미 더 적은값으로 한번 돌림을 뜻하기 때문이다.

플로이드 워셜 알고리즘 O(V^3)
"'모든 지점' 에서 다른 '모든 지점' 까지의 최단 경로 구하는 경우"
점화식으로 표현가능한 다이나믹프로그래밍으로 볼수 있다. Dab = min(Dab,Dak + Dkb)
1) 2차원 그래프 배열 초기화 [자기자신은 0 못가는 경우 INF로 초기화]
2) 선택한 노드 k에 대해서 Dab = min(Dab,Dak + Dkb)
3) 모든 노드에 대해서 2) 반복


다익스트라 예시 인풋
6 11
1
1 2 2
1 3 5
1 4 1
2 3 3
2 4 2
3 2 3
3 6 5
4 3 3
4 5 1
5 3 1
5 6 2

// 답 0 2 3 1 2 4

플로이드 예시 인풋
4 7
1 2 4
1 4 6
2 1 3
2 3 7
3 1 5
3 4 4
4 3 2


//
0 4 8 6
3 0 7 9
5 9 0 4
7 11 2 0

9-1 인풋 예시

5 7
1 2
1 3
1 4
2 4
3 4
3 5
4 5
4 5
//3
4 2
1 3
2 4
3 4
//-1