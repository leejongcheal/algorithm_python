- 서로소 집합(disjoint Sets)
정의: 공통원소가 없는 두 집합
활용: - 무방향 그래프에서 싸이클 검사할때 <-> 방향그래프는 DFS사용
     - 또는 같은 집합을 이루는지 확인필요할때 사용가능
서로소 집합 자료 구조는 find 와 union 연산으로 조작 할수 있음
union(합집합): 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
find(찾기): 특정 원소가 속한 집합을 알려주는 연산
따라서 서로소 집합 자료구조는 union-find자료구조라 부르기도 한다.

서로소 집합 계산 알고리즘(union과정)
1. union 연산을 확인하여, 서로 연결된 두 노드 a, b를 확인한다.
    1) a와 b의 루트노드 A B를 찾는다.
    2) A를 B의 부모 노드로 설정한다.
    ** 보통 작은값을 부모 노드로 설정
2. 모든 union 연산을 처리 할때까지 1번 과정 반복

find 함수에서 메모리제이션을 통해서 재귀반복을 줄이자.
시간 복잡도 노드 V개 최대 V-1 유니언연산 M개의 find 연산일때 O(V + M(1+logV))를 가짐
대충  노드 1000개에 연산이 100만번 정도 수행될때 1000만번정도 연산

***서로소 집합을 활용한 사이클 판별***
    - 무방향 그래프 내에서 사용 가능
    - 방향 그래프는 DFS 사용
과정
1. 각 간선의 두 노드에 대해서 루트 노드 확인한다.
    1) 루트 노드가 서로 다르면 두 노드에 대해서 union 연산 수행
    2) 루트 노드가 서로 같다면 '사이클'이 발생한 것
    why? 3개의 노드가 사이클일때 간선은 최소 3개 필요
    2번의 union으로 3개의 노드가 같은 루트를 가지게 된 상태에서 3번째의 간선에 대해서 조사하면 루트가 같게 나온다 -> 사이클 발생
2. 그래프에 있는 모든 간선에 대해서 1. 반복

- 신장트리 - 대표알고리즘 크루스칼 알고리즘
정의: 하나의 그래프가 있을때 '모든 노드를 포함' 하면서 '사이클이 존재하지 않는' 부분 그래프를 의미
활용: N개의 도시가 있고 이중 랜덤으로 뽑은 A,B에 대해 A에서 B로 이동하는 경로가 반드시 존재하면서 '모든 도시를 연결'을 최소한의 비용으로
-> 최소 신장 트리 알고리즘 -> 대표: 크루스칼 알고리즘

    - 크루스칼 알고리즘 O(ElogE)
과정
요약: 비용이 작은 간선부터 추가하면서 사이클을 추가 하는 간선은 무시
1. 간선 데이터를 비용에 따라 오름차순으로 정렬
2. 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인한다. -- 서로소집합 사용
    1) 사이클이 발생하지 않는경우 최소 신장트리에 포함한다.
    2) 사이클이 발생하는 경우 최소 신장 트리에 포함시키지 않는다.
3. 모든 간선에 대하여 2번 과정을 반복한다.


- 위상 정렬 O(V+E)
정의: 순서가 정해져 있는 일련의 작업을 차례대로 수행해야 할 때 사용할 수 있는 알고리즘
"방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열 하는것"
진입차수: 특정한 노드로 들어오는 '간선의 개수'

과정
1. 초기화후 진입 차수가 0인 노드를 큐에 넣는다
2. 큐가 빌 때까지 다음의 과정 반복
    1) 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다. [해당 정점 indegree -1 해주면 됨]
    2) 새롭게 진입차수가 0이된 노드를 큐에 넣는다.[위의 연산으로 0이 된 index를 q에 삽입]

*** 이때 모든 원소를 방문 하기전에 큐가 빈다면 사이클 존재함을 알수 있다.
큐에서 빠져나간 노드를 순서대로 출력하면 위상정렬 , 답은 여러개 가능하다.



크루스칼 알고리즘 예시 인풋
7 9
1 2 29
1 5 75
2 3 35
2 6 34
3 4 7
4 6 23
4 7 13
5 6 53
6 7 25
/// 159

위상정렬 알고리즘 예시 인풋
7 8
1 2
1 5
2 3
2 6
3 4
4 7
5 6
6 4
// 1 2 5 3 6 4 7 등등

10-1 인풋
7 8
0 1 3
1 1 7
0 7 6
1 7 1
0 3 7
0 4 2
0 1 1
1 1 1
// NO NO YES

10-2
7 12
1 2 3
1 3 2
3 2 1
2 5 2
3 4 4
7 3 6
5 1 5
1 6 2
6 4 1
6 5 3
4 5 3
6 7 4
// 8
10-3
5
10 -1
10 1 -1
4 1 -1
4 3 1 -1
3 3 -1
//10 20 14 18 17